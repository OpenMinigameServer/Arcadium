From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: NickAcPT <32451103+NickAcPT@users.noreply.github.com>
Date: Wed, 5 May 2021 19:01:07 +0100
Subject: [PATCH] Add Hologram framework


diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index c1aeef69d853b56cffa56ccd2565cf8fcb2bc3cb..a9f729d385d4be2b8cc4ac954c23754358022f86 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -998,6 +998,7 @@ public abstract class MinecraftServer extends IAsyncTaskHandlerReentrant<TickTas
     }
     public void safeShutdown(boolean flag, boolean isRestarting) {
         net.pl3x.purpur.task.TPSBarTask.stop(); // Purpur
+        org.screamingsandals.lib.bukkit.hologram.BukkitHologramManager.getInstance().destroy(); // Arcadium
         this.isRunning = false;
         this.isRestarting = isRestarting;
         this.hasLoggedStop = true; // Paper
diff --git a/src/main/java/net/minecraft/server/network/PlayerConnection.java b/src/main/java/net/minecraft/server/network/PlayerConnection.java
index 71ed37eee51ac024dd3805362de25933246a8001..25ef3688abb39346bee0fc530c9b689d5ca75cde 100644
--- a/src/main/java/net/minecraft/server/network/PlayerConnection.java
+++ b/src/main/java/net/minecraft/server/network/PlayerConnection.java
@@ -151,7 +151,6 @@ import net.minecraft.world.level.block.entity.TileEntityCommand;
 import net.minecraft.world.level.block.entity.TileEntityJigsaw;
 import net.minecraft.world.level.block.entity.TileEntitySign;
 import net.minecraft.world.level.block.entity.TileEntityStructure;
-import net.minecraft.world.level.block.state.BlockBase;
 import net.minecraft.world.level.block.state.IBlockData;
 import net.minecraft.world.phys.AxisAlignedBB;
 import net.minecraft.world.phys.MovingObjectPositionBlock;
@@ -221,6 +220,7 @@ import org.bukkit.inventory.InventoryView;
 import org.bukkit.inventory.SmithingInventory;
 import org.bukkit.util.NumberConversions;
 import co.aikar.timings.MinecraftTimings; // Paper
+import org.screamingsandals.lib.bukkit.hologram.BukkitHologramManager;
 // CraftBukkit end
 
 public class PlayerConnection implements PacketListenerPlayIn {
@@ -2464,6 +2464,9 @@ public class PlayerConnection implements PacketListenerPlayIn {
             return;
         }
         // Spigot End
+        // Arcadium start
+        BukkitHologramManager.getInstance().onEntityUsePacket(getPlayer(), packetplayinuseentity);
+        // Arcadium end
 
         this.player.resetIdleTimer();
         this.player.setSneaking(packetplayinuseentity.e());
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index 3f0eff625e1c31a7da51f701943fcf46e847a819..4b1328e46da60efb064b9c0290ea8b6867831a2d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -222,6 +222,9 @@ import org.bukkit.potion.PotionEffectType;
 import org.bukkit.scheduler.BukkitWorker;
 import org.bukkit.util.StringUtil;
 import org.bukkit.util.permissions.DefaultPermissions;
+import org.jetbrains.annotations.NotNull;
+import org.screamingsandals.lib.bukkit.hologram.BukkitHologramManager;
+import org.screamingsandals.lib.hologram.Hologram;
 import org.yaml.snakeyaml.Yaml;
 import org.yaml.snakeyaml.constructor.SafeConstructor;
 import org.yaml.snakeyaml.error.MarkedYAMLException;
@@ -2542,4 +2545,28 @@ public final class CraftServer implements Server {
         return getServer().lagging;
     }
     // Purpur end
+
+    // Arcadium start
+    @NotNull
+    @Override
+    public Hologram createHologram(@NotNull Location location) {
+        return BukkitHologramManager.createHologram(location);
+    }
+
+    @NotNull
+    @Override
+    public Hologram createTouchableHologram(@NotNull Location location) {
+        return BukkitHologramManager.createHologram(location, true);
+    }
+
+    public void removeHologram(@NotNull Hologram hologram) {
+        BukkitHologramManager.removeHologram(hologram);
+    }
+
+    @org.jetbrains.annotations.Nullable
+    public Hologram getHologram(@NotNull UUID id) {
+        return BukkitHologramManager.getHologram(id).orElse(null);
+    }
+
+    // Arcadium end
 }
diff --git a/src/main/java/org/screamingsandals/lib/bukkit/hologram/BukkitHologram.java b/src/main/java/org/screamingsandals/lib/bukkit/hologram/BukkitHologram.java
new file mode 100644
index 0000000000000000000000000000000000000000..5eb477e3180dee16ccd2016a1275bcdea86cd745
--- /dev/null
+++ b/src/main/java/org/screamingsandals/lib/bukkit/hologram/BukkitHologram.java
@@ -0,0 +1,379 @@
+package org.screamingsandals.lib.bukkit.hologram;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Lists;
+import com.mojang.datafixers.util.Pair;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.stream.Stream;
+import net.minecraft.network.protocol.Packet;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityDestroy;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityEquipment;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityMetadata;
+import net.minecraft.network.protocol.game.PacketPlayOutEntityTeleport;
+import net.minecraft.network.protocol.game.PacketPlayOutSpawnEntityLiving;
+import net.minecraft.world.entity.decoration.EntityArmorStand;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.CraftEquipmentSlot;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftArmorStand;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.EquipmentSlot;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.scheduler.BukkitRunnable;
+import org.bukkit.scheduler.BukkitTask;
+import org.bukkit.util.EulerAngle;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.screamingsandals.lib.hologram.AbstractHologram;
+import org.screamingsandals.lib.hologram.Hologram;
+
+public class BukkitHologram extends AbstractHologram {
+    private final Map<Integer, CraftArmorStand> entitiesOnLines = new ConcurrentHashMap<>();
+    private CraftArmorStand itemEntity;
+    private @Nullable BukkitTask rotationTask;
+    private Location cachedLocation;
+
+    BukkitHologram(UUID uuid, Location location, boolean touchable) {
+        super(uuid, location, touchable);
+        this.cachedLocation = location;
+    }
+
+    public boolean hasId(int id) {
+        return entitiesOnLines.values()
+                .stream()
+                .anyMatch(entity -> entity.getEntityId() == id);
+    }
+
+    @Override
+    public @NotNull Hologram setLocation(@NotNull Location location) {
+        this.location = location;
+        this.cachedLocation = location;
+        return this;
+    }
+
+    @Override
+    public void removeHologram() {
+        BukkitHologramManager.removeHologram(this);
+    }
+
+    @Override
+    public void onViewerAdded(@NotNull Player player, boolean shouldCheckDistance) {
+        try {
+            if (visible && entitiesOnLines.size() != lines.size()) { // fix if you show hologram and then you add viewers
+                updateEntities();
+            }
+
+            update(player, getAllSpawnPackets(), shouldCheckDistance);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public void onViewerRemoved(@NotNull Player player, boolean shouldCheckDistance) {
+        try {
+            removeForPlayer(player);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+    }
+
+    @Override
+    public @NotNull Hologram show() {
+        super.show();
+        if (rotationMode != RotationMode.NONE) {
+            rotationTask = new BukkitRunnable() {
+                @Override
+                public void run() {
+                    if (itemEntity == null) {
+//                        log.trace("Item entity is null");
+                        return;
+                    }
+
+                    itemEntity.setHeadPose(checkAndAdd(itemEntity.getHeadPose()));
+
+                    try {
+                        viewers.forEach(player -> update(player, Lists.newArrayList(new PacketPlayOutEntityMetadata(
+                                itemEntity.getEntityId(), itemEntity.getHandle().getDataWatcher(), false
+                        )), false));
+                    } catch (Throwable t) {
+                        t.printStackTrace();
+                    }
+                }
+            }.runTaskTimerAsynchronously(new MinecraftInternalPlugin(), 0L, rotationTime);
+        }
+
+        return this;
+    }
+
+    @Override
+    public @NotNull Hologram hide() {
+        viewers.forEach(viewer -> {
+            try {
+                removeForPlayer(viewer);
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        });
+
+        if (rotationTask != null) {
+            rotationTask.cancel();
+            rotationTask = null;
+        }
+        super.hide();
+        return this;
+    }
+
+    @Override
+    public @NotNull Hologram setItem(@NotNull ItemStack item) {
+        super.setItem(item);
+        if (ready) {
+            viewers.forEach(player -> {
+                try {
+                    update(player, Lists.newArrayList(getEquipmentPacket(itemEntity, item)), true);
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            });
+        }
+        return this;
+    }
+
+    @Override
+    public void destroy() {
+        if (rotationTask != null) {
+            rotationTask.cancel();
+        }
+        super.destroy();
+    }
+
+    @Override
+    protected void update0() {
+        updateEntities();
+    }
+
+    private void update(@NotNull Player player, @NotNull List<Object> packets, boolean checkDistance) {
+        if (!player.getLocation().getWorld().equals(cachedLocation.getWorld())) {
+            return;
+        }
+
+        if (checkDistance
+                && player.getLocation().distanceSquared(cachedLocation) >= viewDistance) {
+            return;
+        }
+
+        packets.forEach(p -> {
+            ((CraftPlayer) player).getHandle().playerConnection.sendPacket((Packet<?>) p);
+        });
+        //ClassStorage.sendPackets(player, packets);
+    }
+
+    private void updateEntities() {
+        final @NotNull LinkedList<Object> packets = new LinkedList<>();
+        if (visible && viewers.size() > 0) {
+            if (lines.size() != originalLinesSize
+                    && itemEntity != null) {
+                itemEntity.teleport(cachedLocation.clone().add(0, itemPosition == ItemPosition.BELOW
+                        ? (-lines.size() * .25 - .5)
+                        : (lines.size() * .25), 0));
+
+                try {
+                    packets.add(getTeleportPacket(itemEntity));
+                } catch (Exception e) {
+                    e.printStackTrace();
+                }
+            }
+
+            lines.forEach((key, value) -> {
+                try {
+                    if (entitiesOnLines.containsKey(key)) {
+                        final CraftArmorStand entityOnLine = entitiesOnLines.get(key);
+                        if (entityOnLine.getCustomName().equals(value)
+                                && originalLinesSize == lines.size()) {
+                            return;
+                        }
+
+                        entityOnLine.customName(value.getText());
+                        final @NotNull PacketPlayOutEntityMetadata metadataPacket =
+                                new PacketPlayOutEntityMetadata(entityOnLine.getEntityId(), entityOnLine.getHandle().getDataWatcher(), false);
+                        packets.add(metadataPacket);
+
+                        entityOnLine.customName(value.getText());
+                        entityOnLine.teleport(cachedLocation.clone().add(0, (lines.size() - key) * .25, 0));
+                        packets.add(getTeleportPacket(entityOnLine));
+                    } else {
+                        final @NotNull Location newLocation = cachedLocation.clone().add(0, (lines.size() - key) * .25, 0);
+                        final @NotNull CraftArmorStand entity = new CraftArmorStand(((CraftServer) Bukkit.getServer()), new EntityArmorStand(((CraftWorld) newLocation.getWorld()).getHandle(), newLocation.getX(), newLocation.getY(), newLocation.getZ()));
+                        entity.customName(value.getText());
+                        entity.setCustomNameVisible(true);
+                        entity.setInvisible(true);
+                        entity.setSmall(!touchable);
+                        entity.setArms(false);
+                        entity.setBasePlate(false);
+                        entity.setGravity(false);
+                        entity.setMarker(!touchable);
+
+                        packets.addAll(getSpawnPacket(entity));
+
+                        entitiesOnLines.put(key, entity);
+                    }
+                } catch (Throwable throwable) {
+                    throwable.printStackTrace();
+                }
+            });
+
+            try {
+                if (rotationMode != RotationMode.NONE) {
+                    if (itemEntity == null) {
+                        final @NotNull Location newLocation = cachedLocation.clone().add(0, itemPosition == ItemPosition.BELOW
+                                ? (-lines.size() * .25 - .5)
+                                : (lines.size() * .25), 0);
+                        final @NotNull CraftArmorStand entity = new CraftArmorStand(((CraftServer) Bukkit.getServer()), new EntityArmorStand(((CraftWorld) newLocation.getWorld()).getHandle(), newLocation.getX(), newLocation.getY(), newLocation.getZ()));
+                        entity.setInvisible(true);
+                        entity.setSmall(!touchable);
+                        entity.setArms(false);
+                        entity.setBasePlate(false);
+                        entity.setGravity(false);
+                        entity.setMarker(!touchable);
+
+                        packets.addAll(getSpawnPacket(entity));
+                        packets.add(getEquipmentPacket(entity, item));
+
+                        this.itemEntity = entity;
+                    }
+                }
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+        }
+
+        try {
+            final @NotNull LinkedList<Integer> toRemove = new LinkedList<Integer>();
+            if (entitiesOnLines.size() > lines.size()) {
+                entitiesOnLines.forEach((key, value) -> {
+                    if (!lines.containsKey(key)) {
+                        toRemove.add(value.getEntityId());
+                    }
+                });
+            }
+
+            final @NotNull PacketPlayOutEntityDestroy destroyPacket = new PacketPlayOutEntityDestroy(toRemove.stream().mapToInt(i -> i).toArray());
+            packets.add(destroyPacket);
+        } catch (Throwable t) {
+            t.printStackTrace();
+        }
+
+        viewers.forEach(viewer -> update(viewer, packets, true));
+    }
+
+    private @NotNull PacketPlayOutEntityEquipment getEquipmentPacket(@NotNull CraftArmorStand entity, ItemStack item) {
+        return new PacketPlayOutEntityEquipment(entity.getEntityId(),
+                Lists.newArrayList(Pair.of(CraftEquipmentSlot.getNMS(EquipmentSlot.HEAD), stackAsNMS(item))));
+    }
+
+    private @NotNull PacketPlayOutEntityTeleport getTeleportPacket(@NotNull CraftArmorStand entity) {
+        return new PacketPlayOutEntityTeleport(entity.getHandle());
+    }
+
+    private @NotNull List<Object> getSpawnPacket(@NotNull CraftArmorStand entity) {
+        final @NotNull LinkedList<Object> toReturn = new LinkedList<>();
+        toReturn.add(new PacketPlayOutSpawnEntityLiving(entity.getHandle()));
+        toReturn.add(new PacketPlayOutEntityMetadata(entity.getEntityId(), entity.getHandle().getDataWatcher(), true));
+        return toReturn;
+    }
+
+    private @NotNull Object getFullDestroyPacket() throws IllegalArgumentException, SecurityException {
+        final Stream<Integer> lines = entitiesOnLines.values()
+                .stream()
+                .map(CraftEntity::getEntityId);
+
+        final int[] toRemove;
+        if (itemEntity != null) {
+            toRemove = Stream.concat(lines, Stream.of(itemEntity.getEntityId()))
+                    .mapToInt(i -> i)
+                    .toArray();
+        } else {
+            toRemove = lines.mapToInt(i -> i).toArray();
+        }
+
+        return new PacketPlayOutEntityDestroy(toRemove);
+    }
+
+    private @NotNull List<Object> getAllSpawnPackets() {
+        final @NotNull LinkedList<Object> packets = new LinkedList<>();
+        entitiesOnLines.forEach((line, entity) -> {
+            try {
+                packets.addAll(getSpawnPacket(entity));
+            } catch (Exception e) {
+                throw new UnsupportedOperationException(e);
+            }
+        });
+
+        if (itemEntity != null) {
+            try {
+                packets.addAll(getSpawnPacket(itemEntity));
+                packets.add(getEquipmentPacket(itemEntity, item));
+            } catch (Exception e) {
+                e.printStackTrace();
+            }
+        }
+        return packets;
+    }
+
+    private @NotNull EulerAngle checkAndAdd(@NotNull EulerAngle in) {
+        switch (rotationMode) {
+            case X:
+                return in.setX(checkAndIncrement(in.getX()));
+            case Y:
+                return in.setY(checkAndIncrement(in.getY()));
+            case Z:
+                return in.setZ(checkAndIncrement(in.getZ()));
+            case XY:
+                return in.setX(checkAndIncrement(in.getX()))
+                        .setX(checkAndIncrement(in.getY()));
+            case ALL:
+                return in.setX(checkAndIncrement(in.getX()))
+                        .setY(checkAndIncrement(in.getY()))
+                        .setZ(checkAndIncrement(in.getZ()));
+        }
+
+        return in;
+    }
+
+    private double checkAndIncrement(double in) {
+        if (in >= 370) {
+            return 0;
+        } else {
+            return in + rotationIncrement;
+        }
+    }
+
+    private net.minecraft.world.item.ItemStack stackAsNMS(ItemStack item) {
+        Preconditions.checkNotNull(item, "Item is null!");
+        return CraftItemStack.asNMSCopy(item);
+    }
+
+    private void removeForPlayer(@NotNull Player player) {
+        if (!player.isOnline()) {
+            return;
+        }
+
+        final @NotNull LinkedList<Object> toSend = new LinkedList<>();
+        if (itemEntity != null) {
+            rotationTask.cancel();
+        }
+
+        toSend.add(getFullDestroyPacket());
+        update(player, toSend, false);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/screamingsandals/lib/bukkit/hologram/BukkitHologramManager.java b/src/main/java/org/screamingsandals/lib/bukkit/hologram/BukkitHologramManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..e1d821ba157e63ee2824aed11cd57bb9fedf2702
--- /dev/null
+++ b/src/main/java/org/screamingsandals/lib/bukkit/hologram/BukkitHologramManager.java
@@ -0,0 +1,296 @@
+package org.screamingsandals.lib.bukkit.hologram;
+
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.UUID;
+import net.minecraft.network.protocol.game.PacketPlayInUseEntity;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.scheduler.MinecraftInternalPlugin;
+import org.bukkit.entity.Player;
+import org.bukkit.event.EventHandler;
+import org.bukkit.event.Listener;
+import org.bukkit.event.player.PlayerChangedWorldEvent;
+import org.bukkit.event.player.PlayerMoveEvent;
+import org.bukkit.event.player.PlayerQuitEvent;
+import org.bukkit.event.player.PlayerRespawnEvent;
+import org.bukkit.event.player.PlayerTeleportEvent;
+import org.bukkit.event.server.PluginDisableEvent;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.PluginManager;
+import org.jetbrains.annotations.NotNull;
+import org.screamingsandals.lib.hologram.AbstractHologram;
+import org.screamingsandals.lib.hologram.Hologram;
+import org.screamingsandals.lib.hologram.event.HologramTouchEvent;
+
+public class BukkitHologramManager {
+
+    private static BukkitHologramManager _instance;
+
+    public static BukkitHologramManager getInstance() {
+        if (_instance == null)
+            _instance = new BukkitHologramManager(new MinecraftInternalPlugin());
+        return _instance;
+    }
+
+    protected final Map<UUID, Hologram> activeHolograms = new HashMap<>();
+
+    private BukkitHologramManager(@NotNull Plugin plugin) {
+        @NotNull PluginManager pluginManager = Bukkit.getPluginManager();
+        pluginManager.registerEvents(new Listener() {
+            @EventHandler
+            public void on(@NotNull PlayerQuitEvent e) {
+                onLeave(e);
+            }
+
+            @EventHandler
+            public void on(@NotNull PlayerMoveEvent e) {
+                onMove(e);
+            }
+
+            @EventHandler
+            public void on(@NotNull PlayerRespawnEvent e) {
+                onRespawn(e);
+            }
+
+            @EventHandler
+            public void on(@NotNull PlayerTeleportEvent e) {
+                onTeleport(e);
+            }
+
+            @EventHandler
+            public void on(@NotNull PlayerChangedWorldEvent e) {
+                onWorldChange(e);
+            }
+        }, plugin);
+    }
+
+    public static @NotNull Map<UUID, Hologram> getActiveHolograms() {
+        return Map.copyOf(getInstance().activeHolograms);
+    }
+
+    public static Optional<Hologram> getHologram(UUID uuid) {
+        return Optional.ofNullable(getActiveHolograms().get(uuid));
+    }
+
+    public static void addHologram(@NotNull Hologram hologram) {
+        getInstance().activeHolograms.put(hologram.getUuid(), hologram);
+    }
+
+    public static void removeHologram(UUID uuid) {
+        getHologram(uuid).ifPresent(BukkitHologramManager::removeHologram);
+    }
+
+    public static void removeHologram(@NotNull Hologram hologram) {
+        getInstance().activeHolograms.remove(hologram.getUuid());
+    }
+
+    public static @NotNull Hologram createHologram(Location holder) {
+        return createHologram(UUID.randomUUID(), holder, false);
+    }
+
+    public static @NotNull Hologram createHologram(Location holder, boolean touchable) {
+        return createHologram(UUID.randomUUID(), holder, touchable);
+    }
+
+    public static @NotNull Hologram createHologram(UUID uuid, Location holder) {
+        return createHologram(uuid, holder, false);
+    }
+
+    public static @NotNull Hologram createHologram(UUID uuid, Location holder, boolean touchable) {
+        final @NotNull Hologram hologram = getInstance().hologram0(uuid, holder, touchable);
+        addHologram(hologram);
+        return hologram;
+    }
+
+    public void onEntityUsePacket(@NotNull Player sender, @NotNull PacketPlayInUseEntity packet) {
+        final int entityId = packet.getEntityId();
+        for (Map.@NotNull Entry<UUID, Hologram> entry : getActiveHolograms().entrySet()) {
+            UUID id = entry.getKey();
+            Hologram hologram = entry.getValue();
+            if (hologram instanceof BukkitHologram) {
+                final @NotNull BukkitHologram textHologram = (BukkitHologram) hologram;
+                if (textHologram.hasId(entityId)) {
+                    (new HologramTouchEvent(sender, hologram)).callEvent();
+                    break; // don't continue in iteration if we found the hologram
+                }
+            }
+        }
+
+    }
+
+    protected @NotNull Hologram hologram0(UUID uuid, Location holder, boolean touchable) {
+        return new BukkitHologram(uuid, holder, touchable);
+    }
+
+    private void onLeave(@NotNull PlayerQuitEvent event) {
+        if (activeHolograms.isEmpty()) {
+            return;
+        }
+
+        getActiveHolograms().forEach((key, hologram) -> {
+            if (hologram.getViewers().contains(event.getPlayer())) {
+                hologram.removeViewer(event.getPlayer());
+            }
+            if (!hologram.hasViewers()) {
+                removeHologram(hologram);
+            }
+        });
+    }
+
+    private void onMove(@NotNull PlayerMoveEvent event) {
+        if (activeHolograms.isEmpty()) {
+            return;
+        }
+
+        getActiveHolograms().forEach((key, hologram) -> {
+            try {
+                if (!hologram.hasViewers()) {
+                    return;
+                }
+
+                final @NotNull Player player = event.getPlayer();
+                final @NotNull Collection<Player> viewers = hologram.getViewers();
+                final Location hologramLocation = hologram.getLocation();
+                if (hologramLocation == null) {
+                    return;
+                }
+
+                final @NotNull AbstractHologram castedHologram = (AbstractHologram) hologram;
+                final int viewDistance = hologram.getViewDistance();
+                if (viewers.contains(player)
+                        && hologramLocation.getWorld().equals(player.getLocation().getWorld())) {
+                    if (event.getTo().distanceSquared(hologramLocation) < viewDistance
+                            && event.getFrom().distanceSquared(hologramLocation) >= viewDistance) {
+                        castedHologram.onViewerAdded(player, false);
+                    } else if (event.getTo().distanceSquared(hologramLocation) >= viewDistance
+                            && event.getFrom().distanceSquared(hologramLocation) < viewDistance) {
+                        castedHologram.onViewerRemoved(player, false);
+                    }
+                }
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+        });
+    }
+
+    private void onRespawn(@NotNull PlayerRespawnEvent event) {
+        if (activeHolograms.isEmpty()) {
+            return;
+        }
+
+        getActiveHolograms().forEach((key, hologram) -> {
+            try {
+                if (!hologram.hasViewers()) {
+                    return;
+                }
+
+                final @NotNull Player player = event.getPlayer();
+                final @NotNull Collection<Player> viewers = hologram.getViewers();
+                final Location hologramLocation = hologram.getLocation();
+                if (hologramLocation == null) {
+                    return;
+                }
+
+                final @NotNull AbstractHologram castedHologram = (AbstractHologram) hologram;
+                final int viewDistance = hologram.getViewDistance();
+                if (viewers.contains(player)
+                        && event.getWorld().equals(hologramLocation.getWorld())) {
+                    if (player.getLocation().distanceSquared(hologramLocation) < viewDistance) {
+                        Bukkit.getScheduler().runTaskLaterAsynchronously(new MinecraftInternalPlugin(), () -> {
+                            castedHologram.onViewerAdded(player, false);
+                        }, 20);
+                    }
+                }
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+        });
+    }
+
+    private void onWorldChange(@NotNull PlayerChangedWorldEvent event) {
+        if (activeHolograms.isEmpty()) {
+            return;
+        }
+
+        getActiveHolograms().forEach((key, hologram) -> {
+            try {
+                if (!hologram.hasViewers()) {
+                    return;
+                }
+
+                final @NotNull Player player = event.getPlayer();
+                final @NotNull Collection<Player> viewers = hologram.getViewers();
+                final Location hologramLocation = hologram.getLocation();
+                if (hologramLocation == null) {
+                    return;
+                }
+
+                final @NotNull AbstractHologram castedHologram = (AbstractHologram) hologram;
+                final int viewDistance = hologram.getViewDistance();
+                if (viewers.contains(player)
+                        && event.getFrom().equals(hologramLocation.getWorld())) {
+                    if (player.getLocation().distanceSquared(hologramLocation) < viewDistance) {
+                        Bukkit.getScheduler().runTaskLaterAsynchronously(new MinecraftInternalPlugin(), () -> {
+                            castedHologram.onViewerAdded(player, false);
+                        }, 20);
+                    }
+                }
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+        });
+    }
+
+    private void onTeleport(@NotNull PlayerTeleportEvent event) {
+        if (activeHolograms.isEmpty()
+                || !event.getFrom().getWorld().equals(event.getTo().getWorld())) {
+            return;
+        }
+
+        getActiveHolograms().forEach((key, hologram) -> {
+            try {
+                if (!hologram.hasViewers()) {
+                    return;
+                }
+
+                final @NotNull Player player = event.getPlayer();
+                final @NotNull Collection<Player> viewers = hologram.getViewers();
+                final Location hologramLocation = hologram.getLocation();
+                if (hologramLocation == null) {
+                    return;
+                }
+
+                final @NotNull AbstractHologram castedHologram = (AbstractHologram) hologram;
+                final int viewDistance = hologram.getViewDistance();
+                if (viewers.contains(player)
+                        && hologramLocation.getWorld().equals(player.getLocation().getWorld())) {
+                    if (event.getTo().distanceSquared(hologramLocation) < viewDistance
+                            && event.getFrom().distanceSquared(hologramLocation) >= viewDistance) {
+                        Bukkit.getScheduler().runTaskLaterAsynchronously(new MinecraftInternalPlugin(), () -> {
+                            castedHologram.onViewerAdded(player, false);
+                        }, 10);
+                    } else if (event.getTo().distanceSquared(hologramLocation) >= viewDistance
+                            && event.getFrom().distanceSquared(hologramLocation) < viewDistance) {
+
+                        Bukkit.getScheduler().runTaskLaterAsynchronously(new MinecraftInternalPlugin(), () -> {
+                            castedHologram.onViewerRemoved(player, false);
+                        }, 10);
+                    }
+                }
+            } catch (Throwable t) {
+                t.printStackTrace();
+            }
+        });
+    }
+
+    public void destroy() {
+        Map.copyOf(getActiveHolograms())
+                .values()
+                .forEach(Hologram::destroy);
+        activeHolograms.clear();
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/org/screamingsandals/lib/hologram/AbstractHologram.java b/src/main/java/org/screamingsandals/lib/hologram/AbstractHologram.java
new file mode 100644
index 0000000000000000000000000000000000000000..eb7c20c0cdf5dbd23acac9697cac8026c1b34c90
--- /dev/null
+++ b/src/main/java/org/screamingsandals/lib/hologram/AbstractHologram.java
@@ -0,0 +1,381 @@
+package org.screamingsandals.lib.hologram;
+
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+import java.util.concurrent.ConcurrentSkipListMap;
+import java.util.concurrent.CopyOnWriteArrayList;
+import net.kyori.adventure.text.Component;
+import org.bukkit.Location;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
+import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
+import org.bukkit.entity.Player;
+import org.bukkit.inventory.ItemStack;
+import org.bukkit.persistence.PersistentDataContainer;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import org.screamingsandals.lib.bukkit.hologram.BukkitHologramManager;
+import org.screamingsandals.lib.utils.visual.TextEntry;
+import org.screamingsandals.lib.visuals.utils.VisualUtils;
+
+public abstract class AbstractHologram implements Hologram {
+    protected final List<Player> viewers = new CopyOnWriteArrayList<>();
+    protected final UUID uuid;
+    protected Location location;
+    protected int viewDistance;
+    protected boolean touchable;
+    protected boolean ready = false;
+    protected @Nullable PersistentDataContainer data;
+    protected double rotationIncrement;
+    protected Integer rotationTime;
+    protected RotationMode rotationMode = RotationMode.NONE;
+    protected ItemStack item;
+    @NotNull
+    protected ConcurrentSkipListMap<Integer, TextEntry> lines = new ConcurrentSkipListMap<>();
+    protected Integer originalLinesSize = 0;
+    protected boolean visible = false;
+
+    @Override
+    public @NotNull ItemPosition getItemPosition() {
+        return itemPosition;
+    }
+
+    protected ItemPosition itemPosition = ItemPosition.ABOVE;
+
+    protected AbstractHologram(UUID uuid, Location location, boolean touchable) {
+        this.uuid = uuid;
+        this.location = location;
+        this.touchable = touchable;
+
+        //default values
+        this.viewDistance = DEFAULT_VIEW_DISTANCE;
+        this.rotationIncrement = DEFAULT_ROTATION_INCREMENT;
+        this.data = new CraftPersistentDataContainer(new CraftPersistentDataTypeRegistry());
+        this.rotationTime = 2;
+    }
+
+    @Override
+    public int getViewDistance() {
+        return viewDistance;
+    }
+
+    @Override
+    public @NotNull Hologram setViewDistance(int viewDistance) {
+        this.viewDistance = viewDistance;
+        return this;
+    }
+
+    @Override
+    public @NotNull Location getLocation() {
+        return location;
+    }
+
+    @Override
+    public @NotNull Hologram setLocation(@NotNull Location location) {
+        this.location = location;
+        update();
+        return this;
+    }
+
+    @Override
+    public boolean isTouchable() {
+        return touchable;
+    }
+
+    @Override
+    public @NotNull Hologram setTouchable(boolean touchable) {
+        this.touchable = touchable;
+        return this;
+    }
+
+    public @NotNull Hologram update() {
+        if (ready) {
+            update0();
+        }
+        return this;
+    }
+
+    public @NotNull Hologram show() {
+        if (isShown()) {
+            return this;
+        }
+
+        ready = true;
+        visible = true;
+        update();
+        return this;
+    }
+
+    public @NotNull Hologram hide() {
+        if (!isShown()) {
+            return this;
+        }
+
+        visible = false;
+        ready = false;
+        update();
+        return this;
+    }
+
+    @Override
+    public @Nullable PersistentDataContainer getData() {
+        return data;
+    }
+
+    @Override
+    public void setData(@Nullable PersistentDataContainer data) {
+        this.data = data;
+    }
+
+    @Override
+    public boolean hasData() {
+        if (data == null) {
+            return false;
+        }
+
+        return !data.isEmpty();
+    }
+
+    @Override
+    public @NotNull Integer getRotationTime() {
+        return rotationTime;
+    }
+
+    @Override
+    public @NotNull Hologram setRotationTime(@NotNull Integer rotatingTime) {
+        this.rotationTime = rotatingTime;
+        update();
+        return this;
+    }
+
+    @Override
+    public @NotNull Hologram setRotationMode(@NotNull RotationMode mode) {
+        this.rotationMode = mode;
+        update();
+        return this;
+    }
+
+    @Override
+    public @NotNull RotationMode getRotationMode() {
+        return rotationMode;
+    }
+
+    @Override
+    public @NotNull Hologram setItem(@NotNull ItemStack item) {
+        this.item = item;
+        update();
+        return this;
+    }
+
+    @Override
+    public @NotNull Hologram setRotationIncrement(float toIncrement) {
+        this.rotationIncrement = toIncrement;
+        return this;
+    }
+
+    @Override
+    public @NotNull Hologram setItemPosition(@NotNull ItemPosition location) {
+        this.itemPosition = location;
+        update();
+        return this;
+    }
+
+    public abstract void onViewerAdded(Player player, boolean checkDistance);
+
+    public abstract void onViewerRemoved(Player player, boolean checkDistance);
+
+    protected abstract void update0();
+
+    public void destroy() {
+        data = null;
+        hide();
+        viewers.clear();
+
+        BukkitHologramManager.removeHologram(this);
+    }
+
+    public boolean isVisible() {
+        return visible;
+    }
+
+    @NotNull
+    public Map<Integer, TextEntry> getLines() {
+        return Collections.unmodifiableMap(lines);
+    }
+
+    @NotNull
+    public Optional<Map.Entry<Integer, TextEntry>> getLineByIdentifier(@NotNull String identifier) {
+        return lines.entrySet()
+                .stream()
+                .filter(next -> next.getValue().getIdentifier().equals(identifier))
+                .findFirst();
+    }
+
+    @NotNull
+    public Hologram setTitle(@NotNull Component title) {
+        return setFirstLine(title);
+    }
+
+    @NotNull
+    public Hologram setFirstLine(@NotNull Component text) {
+        return createNewLine(0, text);
+    }
+
+    @NotNull
+    public Hologram setFirstLine(@NotNull TextEntry text) {
+        return createNewLine(0, text);
+    }
+
+    @NotNull
+    public Hologram setBottomLine(@NotNull Component text) {
+        return setBottomLine(TextEntry.of(text));
+    }
+
+    @NotNull
+    public Hologram setBottomLine(@NotNull TextEntry text) {
+        if (lines.isEmpty()) {
+            return setFirstLine(text);
+        }
+
+        originalLinesSize = lines.size();
+        lines.put(lines.lastKey() + 1, text);
+        update();
+        return this;
+    }
+
+    @NotNull
+    public Hologram replaceLine(@NotNull TextEntry text) {
+        final String identifier = text.getIdentifier();
+        if (identifier.isEmpty()) {
+            return setBottomLine(text);
+        }
+
+        @NotNull final Optional<Map.Entry<Integer, TextEntry>> line = getLineByIdentifier(text.getIdentifier());
+        return line.map(integerTextEntryEntry -> replaceLine(integerTextEntryEntry.getKey(), text)).orElseGet(() -> setBottomLine(text));
+    }
+
+    @NotNull
+    public Hologram replaceLine(@NotNull Integer where, @NotNull Component text) {
+        return replaceLine(where, TextEntry.of(text));
+    }
+
+    @NotNull
+    public Hologram replaceLine(@NotNull Integer where, @NotNull TextEntry text) {
+        if (!lines.containsKey(where)) {
+            return createNewLine(where, text);
+        }
+        originalLinesSize = lines.size();
+        lines.put(where, text);
+        update();
+        return this;
+    }
+
+    @NotNull
+    public Hologram setLines(@NotNull Map<Integer, TextEntry> lines) {
+        originalLinesSize = lines.size();
+        this.lines = new ConcurrentSkipListMap<>(lines);
+        update();
+        return this;
+    }
+
+    @NotNull
+    public Hologram setLines(@NotNull List<Component> lines) {
+        @NotNull final HashMap<Integer, TextEntry> toSet = new HashMap<>();
+        for (int i = 0; i < lines.size(); i++) {
+            toSet.put(i, TextEntry.of(lines.get(i)));
+        }
+        return setLines(toSet);
+    }
+
+    @NotNull
+    public Hologram setLines(@NotNull Set<TextEntry> lines) {
+        @NotNull final List<TextEntry> ls = new ArrayList<>(lines);
+        @NotNull final HashMap<Integer, TextEntry> toSet = new HashMap<>();
+        for (int i = 0; i < ls.size(); i++) {
+            toSet.put(i, ls.get(i));
+        }
+        return setLines(toSet);
+    }
+
+    @NotNull
+    public Hologram createNewLine(@NotNull Integer where, @NotNull Component text) {
+        return createNewLine(where, TextEntry.of(text));
+    }
+
+    @NotNull
+    public Hologram createNewLine(@NotNull Integer where, @NotNull TextEntry text) {
+        originalLinesSize = lines.size();
+        lines = VisualUtils.addEntryAndMoveRest(lines, where, text);
+        update();
+        return this;
+    }
+
+    @NotNull
+    public Hologram removeLine(@NotNull Integer where) {
+        originalLinesSize = lines.size();
+        lines = VisualUtils.removeEntryAndMoveRest(lines, where);
+        update();
+        return this;
+    }
+
+    @NotNull
+    public Hologram removeLine(@NotNull String identifier) {
+        getLineByIdentifier(identifier)
+                .ifPresent(next -> {
+                    originalLinesSize = lines.size();
+                    lines = VisualUtils.removeEntryAndMoveRest(lines, next.getKey());
+                    update();
+                });
+        return this;
+    }
+
+    @NotNull
+    public UUID getUuid() {
+        return uuid;
+    }
+
+    @NotNull
+    public Collection<Player> getViewers() {
+        return Collections.unmodifiableList(viewers);
+    }
+
+    @NotNull
+    public Hologram addViewer(@NotNull Player viewer) {
+        if (!viewers.contains(viewer)) {
+            viewers.add(viewer);
+            onViewerAdded(viewer, true);
+        }
+        return this;
+    }
+
+    @NotNull
+    public Hologram removeViewer(@NotNull Player viewer) {
+        if (viewers.contains(viewer)) {
+            viewers.remove(viewer);
+            onViewerRemoved(viewer, false);
+        }
+        return this;
+    }
+
+    @NotNull
+    public Hologram clearViewers() {
+        hide();
+        viewers.clear();
+        return this;
+    }
+
+    public boolean hasViewers() {
+        return !viewers.isEmpty();
+    }
+
+    public boolean isShown() {
+        return visible;
+    }
+}
